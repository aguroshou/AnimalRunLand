// <auto-generated>
//  automatically generated by the FlatBuffers compiler, do not modify
// </auto-generated>

namespace BeefDefine.FlatBufferSchema
{

using global::System;
using global::BeefDefine.FlatBuffers;

public struct StringKeyValue : IFlatbufferObject
{
    private Table __p;
    public ByteBuffer ByteBuffer
    {
        get
        {
            return __p.bb;
        }
    }
    public static StringKeyValue GetRootAsStringKeyValue(ByteBuffer _bb)
    {
        return GetRootAsStringKeyValue(_bb, new StringKeyValue());
    }
    public static StringKeyValue GetRootAsStringKeyValue(ByteBuffer _bb, StringKeyValue obj)
    {
        return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb));
    }
    public void __init(int _i, ByteBuffer _bb)
    {
        __p.bb_pos = _i;
        __p.bb = _bb;
    }
    public StringKeyValue __assign(int _i, ByteBuffer _bb)
    {
        __init(_i, _bb);
        return this;
    }

    public string StringKey
    {
        get
        {
            int o = __p.__offset(4);
            return o != 0 ? __p.__string(o + __p.bb_pos) : null;
        }
    }
    public ArraySegment<byte>? GetStringKeyBytes()
    {
        return __p.__vector_as_arraysegment(4);
    }
    public string StringValue
    {
        get
        {
            int o = __p.__offset(6);
            return o != 0 ? __p.__string(o + __p.bb_pos) : null;
        }
    }
    public ArraySegment<byte>? GetStringValueBytes()
    {
        return __p.__vector_as_arraysegment(6);
    }

    public static Offset<StringKeyValue> CreateStringKeyValue(FlatBufferBuilder builder,
            StringOffset StringKeyOffset = default(StringOffset),
            StringOffset StringValueOffset = default(StringOffset))
    {
        builder.StartObject(2);
        StringKeyValue.AddStringValue(builder, StringValueOffset);
        StringKeyValue.AddStringKey(builder, StringKeyOffset);
        return StringKeyValue.EndStringKeyValue(builder);
    }

    public static void StartStringKeyValue(FlatBufferBuilder builder)
    {
        builder.StartObject(2);
    }
    public static void AddStringKey(FlatBufferBuilder builder, StringOffset StringKeyOffset)
    {
        builder.AddOffset(0, StringKeyOffset.Value, 0);
    }
    public static void AddStringValue(FlatBufferBuilder builder, StringOffset StringValueOffset)
    {
        builder.AddOffset(1, StringValueOffset.Value, 0);
    }
    public static Offset<StringKeyValue> EndStringKeyValue(FlatBufferBuilder builder)
    {
        int o = builder.EndObject();
        builder.Required(o, 4);  // StringKey
        return new Offset<StringKeyValue>(o);
    }

    public static VectorOffset CreateSortedVectorOfStringKeyValue(FlatBufferBuilder builder, Offset<StringKeyValue>[] offsets)
    {
        Array.Sort(offsets, (Offset<StringKeyValue> o1, Offset<StringKeyValue> o2) => Table.CompareStrings(Table.__offset(4, o1.Value, builder.DataBuffer), Table.__offset(4, o2.Value, builder.DataBuffer), builder.DataBuffer));
        return builder.CreateVectorOfTables(offsets);
    }

    public static StringKeyValue? __lookup_by_key(int vectorLocation, string key, ByteBuffer bb)
    {
        byte[] byteKey = System.Text.Encoding.UTF8.GetBytes(key);
        int span = bb.GetInt(vectorLocation - 4);
        int start = 0;

        while (span != 0)
        {
            int middle = span / 2;
            int tableOffset = Table.__indirect(vectorLocation + 4 * (start + middle), bb);
            int comp = Table.CompareStrings(Table.__offset(4, bb.Length - tableOffset, bb), byteKey, bb);

            if (comp > 0)
            {
                span = middle;
            }
            else if (comp < 0)
            {
                middle++;
                start += middle;
                span -= middle;
            }
            else
            {
                return new StringKeyValue().__assign(tableOffset, bb);
            }
        }

        return null;
    }
};


}
